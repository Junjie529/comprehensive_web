# مقدمه
# تاریخچه
# پروتکل ارتباطی
می‌خواهیم درباره‌ی نحوه‌ی ارتباط برقرار کردن و پیام‌های رد بدل شده در این پروتکل وبساکت حرف بزنیم.
این اطلاعات با استفاده از برنامه‌ی
[wireshark](https://www.wireshark.org/)
برای
capture
کردن پکت‌های وبساکت و برنامه‌ی
[websocat](https://github.com/vi/websocat)
برای ایجاد کلاینت و سرور بدست آورده شده‌اند.

در اولین پکت کلاینت به سرور صرفا از پروتکل
HTTP
استفاده می‌کنیم. به کمک این موضوع می‌توانیم کوکی یا هدر‌های خود را در کلاینت در اولین پیام
handshake
قرار دهیم و صرفا حتی قبل از اولین پیام ما، سرور بتواند این هدر‌ها را بخواند و مثلا به کمک آن‌ها کسی را
authorize
کند یا یوزر آیدی کسی را پیدا کند.
همچنین می‌توان به کمک
headerها
دیتاهای دیگر نظیر تنظیمات داده‌هایی که قرار است در وبساکت فرستاده شود یا دریافت شود را قبل از اولین داده سمت سرور فرستاد. یک نمونه از اولین پکت
websocket hello
را می‌توانید در زیر مشاهده کنید:

```
GET / HTTP/1.1
Host: 127.0.0.1:36215
Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Version: 13
Sec-WebSocket-Key: nQUNu5i0IAAsAQ1SJ814+Q==
```

در خط اول همان طور که مشاهده می‌شود، صرفا گفته‌ایم که می‌خواهیم آدرس
/
را با پروتکل
HTTP/1.1،
GET
کنیم. مثل یک ریکوئست عادی
HTTP!
 علاوه بر هدر
`Host`
که صرفا دامنه‌ی جایی که می‌خواهیم به آن دسترسی پیدا کنیم را مشخص می‌کند، یک سری هدر‌های خاص
websocket
نیز در این پکت وجود دارند.

هدر‌های
`Connection`
و
`Upgrade`
همیشه باید مقادیر
`Upgrade`
و
`websocket`
را داشته باشند.
هدر
`Sec-WebSocket-Version`
ورژن وبساکت را مشخص می‌کند که می‌تواند عدد‌های مختلفی باشد ولی در حال حاضر 13 آخرین ورژن آن است. لیست ورژن‌های آن را می‌تواند از
[اینجا](https://www.iana.org/assignments/websocket/websocket.xml#version-number)
مشاهده کنید.
آخرین هدر
`Sec-WebSocket-Key`
است که صرفا یک دنباله‌ی تصادفی از 16 بایت است که
base64 encoded
شده‌اند. به کمک تمام این 4 هدر سرور متوجه می‌شود که یک کانکشن
valid HTTP
قرار است که برقرار شود.

در ادامه سرور این پکت را در جواب پکت اول می‌فرستد:
```
HTTP/1.1 101 Switching Protocols
Sec-WebSocket-Accept: 8CWk7Sb3eBr5xjSXrWqXILHWrTU=
Connection: Upgrade
Upgrade: websocket
```

همان طور که می‌بینید
status code
درخواست
HTTP
ما
101
است که نشان می‌دهد که قرار است که پروتکل ارتباطی را از
HTTP
به چیز دیگری عوض کنیم. همین طور که از هدر‌های سرور معلوم است، قرار است که پروتکل ارتباطی به وبساکت تغییر یابد!
همچنان مقدار هدر
`Sec-WebSocket-Accept`
بدین صورت حساب می‌شود:

```
Base64(SHA1(Concat(Request.Sec-WebSocket-Key, "258EAFA5-E914-47DA-95CA-C5AB0DC85B11")))
```

به عنوان مثال در همین درخواست در صورتی که رشته‌ی
`nQUNu5i0IAAsAQ1SJ814+Q==258EAFA5-E914-47DA-95CA-C5AB0DC85B11`
را
SHA1
بکنیم و نتیجه‌ را در
base64
بخوانیم برابر
`8CWk7Sb3eBr5xjSXrWqXILHWrTU=`
می‌شود.

در نهایت به پکت‌های دیتای وبساکت می‌رسیم. این پکت‌ها در ابتدا یک هدر 16 بیتی دارند، سپس یک
masking key
اختیاری دارند و در نهایت دیتایی که قرار است فرستاده شود را می‌فرستد.
حال به تحلیل و معرفی بیت‌های هدر می‌پردازیم.

* بیت صفر: `FIN`: این بیت زمانی یک است که می‌خواهیم اعلام کنیم که پیامی که می‌خواستیم بفرستیم تمام شد. پیام‌هایی که در داخل وبساکت فرستاده می‌شوند لزوما پیام‌های کوچکی نیستند و ممکن است که لازم شود که در چند پیام فرستاده شوند. بدین جهت زمانی که آخرین سگمنت از پیامی را می‌فرستیم این بیت را یک می‌کنیم.
* بیت اول تا سوم: این بیت‌ها صرفا رزرو شده برای استفاده در آینده هستند.
* بیت چهارم تا هفتم: `opcode`: این عدد نشان می‌دهد که این چه نوع پیامی است. این عدد می‌تواند حالت زیر را داشته باشد:
  * `0`: این پیام ادامه‌ی پیام قبلی است و باید به انتهای آن چسبانده شود. در این زمان `FIN` صفر است.
  * `1`: زمانی که یک دیتای جدید را می‌خواهیم بفرستیم که نوع آن متن است.
  * `2`: زمانی که یک دیتای جدید را می‌خواهیم بفرستیم که نوع آن باینری است.
  * `8`: زمانی که کانکشن وبساکت را می‌خواهیم ببندیم این فیلد را 8 می‌کنیم.
  * `9`: زمانی که opcode برابر با 9 باشد سرور یا کلاینت مقابل باید بلافاصله یک پیام با opcode برابر 10 را برگرداند. این نوع دستور `ping` نامیده می‌شود
  * `10`: در جواب یک درخواست ping باید فرستاده شود. این نوع دستور `pong` نامیده می‌شود.
* بیت هشتم: این بیت در صورتی که یک باشد دیتای payload به صورت mask شده فرستاده می‌شود. همچنین در صورتی که این بیت یک باشد، یک عدد 16 بیتی دیگر بلافاصله بعد از هدر می‌آید که آنرا `Masking Key` می‌نامیم. این کلید 4 بایت است.
* بیت نهم تا پانزدهم: طول دیتایی که در این بسته آمده است.

در ادامه نیز دیتای ما می‌آید که ممکن است که mask شده باشد یا خیر. در صورتی که mask اتفاق افتاده باشد می‌توان به صورت زیر دیتا را از حالت mask شده خارج نمود:
کافی است که باقی مانده‌ی اندیس بیت بر چهار را حساب کنیم و آن بیت را با بیت منتاظر در عدد چهار بیتی
`Masking Key`
XOR
کنیم. رمزگشایی و رمزنگاری به همین ترتیب انجام می‌شوند.

# مثالی در دنیای واقعی
# پیاده سازی یک برنامه چت ساده
