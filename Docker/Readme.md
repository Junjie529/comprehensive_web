<div dir = 'rtl'>

# داکر ( Docker )

```Docker``` یک پلتفرم متن باز برای توسعه، جابجا کردن و اجرای اپلیکیشن هاست. ```Docker``` به شما اجازه میدهد تا اپلیکیشن خود را از زیرساخت (infrastructure) جدا کنید تا بتوانید سریع تر  نرم افزار خود را توسعه دهید. با داکر میتوانید زیرساخت خود را همانند اپلیکیشن خود مدیریت کنید. ```Docker``` به توسعه‌دهندگان کمک می‌کند تا ظروف نرم‌افزاری (software portable) سبک و قابل حمل را بسازند که کار توسعه، آزمایش و استقرار برنامه‌ها را ساده می‌کند. داکر از محیطی‌های کوچک و بزرگ اجزای هسته سیستم عامل به صورت مشترک استفاده می‌کند که کاربران بتوانند به راحتی یک اپلیکیشن را طراحی یا توسعه دهند که بهترین بخش این مسئله این است که داکر در صورت نیاز این اجزا را از یکدیگر جدا می‌کند و در محیطی که ایزوله نام دارد قرار می‌دهد،  به این محیط و بسته‌ی ایزوله، کانتینر ```Container``` می‌گویند.

## کاربرد داکر چیست؟
```Docker``` دسترسی کاربران به برنامه‌های مختلف حتی در سرور‌های قدیمی را فراهم می‌کند. همچنین داکر این قابلیت را دارد که ارسال و بسته‌بندی برنامه را راحت‌تر انجام دهد. تقریبا پنج سال پیش بود که شخصی به نام ```Solomon Hykes``` کسب و کاری با استفاده از دارکر تاسیس و راه‌اندازی کرد. مهم‌ترین هدفی که این عمل داشت این بود که کاربران راحتر بتوانند با ```Container``` ارتباط برقرار کنند یا به نوعی دیگر با آنان تعامل داشته باشند.

با انتشار نسخه Docker 1.0 خوشبختانه این کسب و کار با موفقیت چشم‌گیری روبه رو شد و با گذشت زمان مخصوصا در سال ۲۰۱۴ کاربران زیادی جذب داکر (Docker) شدند و دارکر محبوبیت زیادی در آن سال‌ها برای خود کسب کرد. با پیشرفت فوق‌العاده‌ی داکر شرکت‌هایی که از سرور‌های قدیمی و ماشین‌های مجازی استفاده می‌کردند، مجاب به استفاده از داکر شدند و سرویس‌ها و سرورهای خود را براساس بستر داکر راه‌اندازی کردند.

نکته حایز اهمیتی که برای داکر وجود داشت این بود که در آن زمان که هنوز داکر در نسخه 1.0 قرار داشت بانک‌های معروف و بزرگ از آن برای سرویس‌ها و سرورهای خود استفاده می‌کردند که این مورد نشان دهنده امنیت بالای داکر در آن زمان بود.

## پلتفرم داکر
داکر این قابلیت را به ما میدهد تا یک اپلیکیشن را در یک محیط ایزوله به نام کانتینر ( Container ) اجرا کنیم. ایزوله بودن و امنیت کانینتر ها باعث میشود که بتوانیم تعداد زیادی کانتینر را روی هاست اجرا کنیم.
کانتینر ها سبک و سریع هستند زیرا نیازی ندارند که مانند ماشین های مجازی سربار Hypervisor را تحمل کنند و مستقیما روی هسته ( Kernel ) کامپیوتر سرویس دهنده اجرا میشوند. این به آن معناست که میتوان تعداد بیشتری کانتینر را روی یک ماشین نسبت به حالتی که از ماشین مجازی استفاده میکنیم اجرا کرد.
البته حتی این قابلیت را نیز داریم که از داکر درون ماشین مجازی نیز استفاده کنیم!

## موتور داکر ( Docker Engine )

انجین داکر یه اپلیکیشن سمت کلاینت و سرور است که قابلیت های زیر را داراست:
- یک سرور که نوعی نرم افزار با مدت زمان اجرای طولانی است که به آن پروسه Deamon  گفته میشود.
- یک REST API که واسط کاربری نرم افزار ها برای ارتباط و دادن دستورات به deamon است.
- یک کلاینت Command Line Interface (CLI)

![enter image description here](https://docs.docker.com/engine/images/engine-components-flow.png)

CLI از REST API داکر برای کنترل و یا ارتباط با Deamon به وسیله نوشتن اسکریپت و یا دستورات مستقیم CLI استفاده میکند.

Deamon در واقع وظیفه ساخت و مدیریت Object های داکر است. این Object ها شامل Image ها، Container ها، Network ها و Volume ها میشوند.

## کارایی داکر
##### تولید سریع و باثبات اپلیکیشن
سناریو زیر را در نظر بگیرید:
- توسعه دهندگان یک پروژه کد های خود را به صورت local روی کامپیوتر خود مینویسند و توسط کانتینر های داکر آن ها را با یکدیگر به اشتراک میگذارند.
- آن ها از داکر استفاده میکنند و اپلیکیشن خود را به یک محیط تست push میکنند و آن را تست میکنند.
- وقتی باگی در نرم افزار پیدا شود آن ها باگ را در محیط local یعنی روی کامپیوتر خود تصحیح میکنند و دوباره به محیط تست میفرستند.
- هنگامی که تست ها با موفقیت انجام شد برای رساندن اپلیکیشن به مشتریان تنها کافیست Image آپدیت شده خود را به محیط اصلی یعنی Production بفرستیم.
- 
دلیل اینکه میتوانیم روی محیط اول یعنی کامپیوتر خود کد بزنیم و سپس روی محیط دوم تست کنیم و سپس کد را به محیط سوم برای استفاده اصلی بفرستیم این است که زیرساخت همه این محیط ها یکسان است و توسط داکر فراهم میشود.

##### گسترش پذیری و ریسپانسیو بودن

کانتینر داکر میتواند روی محیط local شخص توسعه دهنده، روی ماشین مجازی یا ماشین فیزیک درون یک دیتا سنتر، روی فضای ابری و یا ترکیبی از این محیط ها اجرا شوند.

همچنین به وسیله داکر میتوانن در زمان بسیار کمی یعنی تقریبا به صورت real-time اپلیکیشن را به بخش ها کوچکتری تقسیم کرد و یا هر بخش آن را گسترش داد.

##### انجام کار بیشتر روی سخت افزار یکسان
داکر سبک و سریع است. و نسبت به ماشین های مجازی که برپایه Hupervisor ها کار میکنند به شدت کارا و کم هزینه است. داکر برای نرم افزار هایی که زیرساخت فشرده و سنگینی دارند نیز بسیار عالیست.




## معماری داکر
داکر از یک معماری کلاینت-سرور استفاده میکند. کلاینت داکر با Deamon در ارتباط است که ساخت و اجرا و پخش کردن کانتینر های داکر را بر عهده دارد. بخش کلاینت و سرور ( Deamon ) داکر میتوانند روی یک کامپیوتر باشدند یا به صورت Remote با روی سیستم های مجزا با یکدیگر در ارتباط باشند. در هر صورت ارتباط میان این دو همانطور که قبلا توضیح داده شد توسط یک REST API انجام میشود.
![enter image description here](https://docs.docker.com/engine/images/architecture.svg)

###   (Dockerd) Deamon داکر 

به API request های داکر 
گوش میدهد و Object های داکر را مدیریت میکند. 
همچنین یک Deamon میتواند با Deamon های دیگر نیز برای مدیریت سرویس های داکر در ارتباط باشد.

### کلاینت داکر ( Docker )
دستورات را توسط REST API به Deamon میدهد و میتواند به طور همزمان با بیش از یک Deamon در ارتباط باشد.

### رجیستری های داکر
یک رجیستری داکر Image های داکر را در خود نگهداری میکند. 
[Docker Hub](https://hub.docker.com/) یک رجیستری پابلیک است که داکر به صورت پیش فرض از آن استفاده میکند.

## آبجکت های داکر ( Docker Objects )
وقتی که از داکر استفاده میکنید، درواقع در حال استفاده، ساخت و یا تغییر این آبجکت ها هستید.
### Images
یک Image در واقع یک Read-Only Template حاوی دستوراتی برای ساخت یک کانتینر داکر است. معمولا استفاده ما از Image ها به اینصورت است که با تغییر یک Image، Image دیگری را که برای ما مناسب تر است میسازیم. مثلا میتوانیم Image ای بسازیم که برپایه Image اوبونتو است اما یک سرور Apache نیز روی آن نصب میشود.
شما میتوانید از Image های آماده استفاده کنید و یا Image مناسب خود را بسازید.
برای ساختن Image جدید کافی است یک Dockerfile ساده بسازید که در آن دستوراتی نشان دهنده چگونگی ساختن و اجرا کردن Image موجود است.
وقتی که Dockerfile خود را تغییر میدهیم و Image جدیدی میسازیم، تنها بخش های جدید دوباره ساخته میشوند و این یکی از دلایل عمده سرعت و عملکرد بهتر داکر نسبت به بقیه فناوری های شبیه سازی ( Virtualization ) است.

### Containers

Container یک Instance قابل اجرای  یک Image است. میتوان یک کانتینر را به وسیله Docker API  یا CLI ساخت، 
اجرا، حذف و یا متوقف کرد.

معمولا کانتینر ها از دیگر کانتینر های به خوبی ایزوله میشوند. شما میتوانید میزان ایزوله بودن کانتینر ها را در مواردی مانند network آنها، حافظه مورد استفاده آنها و سیستم های پایه ای مورد استفاده آنها تنظیم کنید.

یک کانتینر در واقع با Image آن و همه تنظیماتی که در زمان اجرای آن انجام میدهید تعریف میشود. هنگامی که کانتینر حذف میشود هر تغییری فایلی که در آن به وجود آمده و راهی به بیرون از کانتینر ندارد از بین میرود.

### Container ها و Virtual machine ها
یک کانتینر به صورت native روی لینوکس اجرا میشود و به صورت مشترک با سیستم عامل از کرنل استفاده میکند. کانتیر یک پروسه مجزا را اجرا میکند و مانند یک پروسه معمولی حجم کمی از RAM  را میگیرد.
در مقابل، VM یک سیستم عامل کامل مجازی guest را با دسترسی مجازی و شبیه سازی شده به منابع اصلی سیستم  را توسط یک hypervisor اجرا میکند. VM ها مقدار بسیار زیادی سربار نسبت به حجم پروسه مورد نیاز ما برای سیستم ایجاد میکنند.
![enter image description here](https://docs.docker.com/images/Container@2x.png) ![enter image description here](https://docs.docker.com/images/VM@2x.png)

## راهنمای نصب داکر
برای نصب داکر بر روی سیستم عامل لینوکس خود دو راه وجود دارد:
### روش اول: نصب داکر از ریپوهای پیش فرض

گام اول: آپدیت کردن نرم افزارها

برای اینکه مطمئن شویم از نسخه به به روز نرم افزارها استفاده می‌کنیم، ابتدا دستور زیر را در ترمینال وارد می‌کنیم و صبر می‌کنیم تا فرآیند تمام شود:
<div dir = 'ltr'>
  
```
sudo apt-get update
```  
</div>

گام دوم: حذف نسخه قبلی داکر

برای اینکه از نسخه جدید و به روز شده داکر استفاده کنیم، پیشنهاد می‌شود نسخه قبلی را پاک کنیم، برای این کار دستور زیر را در ترمینال وارد کنید:
<div dir = 'ltr'>
  
```
sudo apt-get remove docker docker-engine docker.io
```  
</div>

گام سوم: نصب داکر

برای نصب داکر بر روی سیستم عامل لینوکس خود دستور زیر را در ترمینال وارد کنید:
<div dir = 'ltr'>
  
```
sudo apt install docker.io
```  
</div>

گام چهارم: بالا آورن داکر

سرویس داکر برای راه اندازی نیاز اجرا در ابتدا دارد، برای این کار دو دستور زیر را در ترمینال، یکی بعد از اجرای دیگری وارد کنید:
<div dir = 'ltr'>
  
```
sudo systemctl start docker
```  
```
sudo systemctl enable docker
```  
</div>

گام پنجم: چک کردن ورژن داکر نصب شده

در انتها برای اطمینان از صحت داکر نصب شده دستور زیر را وارد کرده تا نسخه داکر نصب شده را ببینید:
<div dir = 'ltr'>
  
```
docker --version
```  
</div>

### روش دوم: نصب داکر از ریپو رسمی

گام اول: آپدیت کردن نرم افزارها

برای اینکه مطمئن شویم از نسخه به به روز نرم افزارها استفاده می‌کنیم، ابتدا دستور زیر را در ترمینال وارد می‌کنیم و صبر می‌کنیم تا فرآیند تمام شود
<div dir = 'ltr'>
  
```
sudo apt-get update
```  
</div>

گام دوم: دانلود وابستگی‌ها

برای اینکه به سیستم عامل خود اجازه دهید به ریپوهای Docker از طریق HTTPS دسترسی پیدا کند ، باید این دستورات را در ترمینال اجرا کنید.
<div dir = 'ltr'>
  
```
sudo apt-get install apt-transport-https ca-certificates curl software-properties-common
```  
</div>

برای اینکه دید کلی از دستورات بالا داشته باشیم، تفسیر دستورات بالا اینگونه است:

  - ```apt-transport-https``` : به package manager اجازه می‌دهد تا داده و فایل‌ها را از طریق https انتقال دهد.
  - ```ca-certificates``` : به مرورگر وب اجازه می‌دهد تا گواهی‌های امنیتی را بررسی کند.
  - ```curl``` : این ابزاری برای انتقال داده است.
  - ```software-properties-common``` : اسکریپت‌هایی را برای مدیریت نرم افزار اضافه می‌کند.
  
گام سوم: اضافه کردن Docker’s GPG Key

کلید GPG یک ویژگی امنیتی است، برای اطمینان از معتبر بودن نرم افزاری که نصب می کنید ، دستور زیر را در ترمینال وارد کنید:
<div dir = 'ltr'>
  
```
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add –
```  
</div>
اگر پاسخ OK در ترمینال مشاهده شد یعنی نرم افزار معتبر است.

گام چهارم: نصب ریپو داکر

برای نصب ریپو داکر دستور زیر را در ترمینال وارد کنید:
<div dir = 'ltr'>
  
```
sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu  $(lsb_release -cs)  stable" 
```  
</div>

برای تفسیر دستورات بالا داریم:

  - ```lsb_release –cs``` : در واقع این دستور codename نصب ما را بر ‌گرداند.
  - ```stable``` : این هم در واقع نوع داکر منتشر شده است.
  
گام پنجم: آپدیت کردن ریپوها

برای به روزرسانی ریپوها برای بار دیگر دستور زیر را در ترمینال وارد کنید:
<div dir = 'ltr'>
  
```
sudo apt-get update
```  
</div>

گام ششم: نصب آخرین نسخه داکر

برای نصب آخرین نسخه منتشر شده داکر دستور زیر را وارد کنید:
<div dir = 'ltr'>
  
```
sudo apt-get install docker-ce
```  
</div>

گام هفتم(اختیاری): نصب نسخه مشخص از داکر

برای دسترسی به لیستی از نسخه‌های مختلف داکر منتشر شده دستور زیر را وارد می‌کنیم:
<div dir = 'ltr'>
  
```
apt-cache madison docker-ce
```  
</div>
به شما لیستی از داکرهای منتشر شده نشان داده می‌شود.

برای نصب نسخه مورد نظر می‌توانید دستور زیر را در ترمینال وارد کنید:
<div dir = 'ltr'>
  
```
sudo apt-get install docker-ce=<VERSION>
```  
</div>

که در اینجا <VERSION> همان نسخه داکری است که می‌خواهید نصب کنید، به طور مثال دستور فوق می‌تواند به صورت زیر باشد:
<div dir = 'ltr'>
  
```
sudo apt-get install docker-ce=18.03.1~ce~3-0~ubuntu
```  
</div>

## چه کسانی از Docker استفاده می کنند؟
```Docker``` ابزاری است که هم به درد برنامه نویس ها می خورد و هم به درد مدیرهای شبکه و به همین خاطر هم برخی اوقات به نام ```DevOps``` از آن یاد می شود که ترکیبی از دو اسم Developer و Operations است. برای برنامه نویس ها ```Docker``` به این معنا است که فقط روی کد نویسی خودتان تمرکز کنید و دغدغه اینکه کد شما قرار است بر روی چه سیستم عاملی با چه نیازمندی هایی نصب شود را نداشته باشید اینکار را ```Docker``` برای شما انجام می دهد.

از طرفی هزاران برنامه و نرم افزار متنوع وجود دارند که برای کار کردن در محیط ```Docker``` طراحی شده اند و شما به عنوان یک ITPRO می توانید به راحتی از آنها در مجموعه خودتان در قالب یک Docker Container استفاده کنید. از طرفی در محیط های عملیاتی```Docker``` این امکان را به همه می دهد که چندین برنامه را همزمان بر روی یک سیستم فیزیکی نصب و اجرا کنند و اینها هیچکدام با یکدیگر کوچکترین ارتباطی نداشته باشند و بصورت کاملا ایزوله در مجموعه فعالیت کنند.
## کانتینرها و داکر
```Container``` این امکان را برای برنامه نویسان و توسعه دهندگان اپلیکیشن ها فراهم می کند تا یک برنامه را با تمام ماژول ها و کامپوننت‌های وابسته آن ( مانند کتابخانه ها ، توابع و … ) یکی کرده و به صورت یک پکیج درآورده تا آن برنامه تولید شده در پلتفرم ها و سیستمهای مختلف بدون مشکل اجرا شود، در حقیقت بدون نگرانی از تنظیمات و وابستگ‌های یک Application خاص در پلتفرم های دیگر، آن برنامه در هر محیطی اجرا شود.

## اصطلاحاتی که در زمینه ی داکر استفاده می شوند
### Docker file
داکر یک image را به وسیله ی خواندن دستورات موجود در یک dockerfile می سازد. یک dockerfile یک فایل text است که تمامی دستوراتی که نیاز برای صدا زده شدن است تا یک image ساخته شود.  یک کاربر برای ساختن یک فایل image از دستور ``` docker build ``` استفاده می کند و خود داکر به طور اتوماتیک با استفاده از خواندن دستورات dockerfile این فایل image را می سازد. ورودی و خروجی این کد را در زیر مشاهده می کنید.

<div dir = 'ltr'>
  
```
$ docker build .

Sending build context to Docker daemon  6.51 MB
...
```
</div>

![enter image description here](https://miro.medium.com/max/2400/1*p8k1b2DZTQEW_yf0hYniXw.png)

### Docker image
هنگامی که Dockerfile خود را نوشتید ، برای ساخت یک Image بر اساس آن Dockerfile ، از ابزار  Docker build استفاده می کنید. در حالی که Dockerfile مجموعه دستورالعملهایی است که نحوه ساخت image را به شما می گوید ،  Docker image یک فایل قابل حمل است که حاوی مشخصاتی است برای این که کدام  اجزا نرم افزاری container اجرا خواهند شد و چگونه اجرا می‌شوند. از آنجا که یک Dockerfile احتمالاً شامل دستورالعمل هایی در مورد گرفتن برخی از بسته های نرم افزاری از مخازن آنلاین است ، بنابراین باید دقیقاً نسخه های مناسب را مشخص کنید ، در غیر این صورت ممکن است بسته به زمان استناد ، Dockerfile شما imageهای متناقضی را ایجاد کند.Codefresh نگاهی به نحوه ساختن تصویر با جزئیات بیشتر ارائه می دهد.
### Docker containers
نمونه های در حال اجرایی از Image ها هستند. 
![enter image description here](https://miro.medium.com/max/700/0*ujI404Gnomn1Wz5h.png)

### Docker Hub
Docker Hub (داکر هاب) یک سرویس اشتراک‌گذاری تهیه شده توسط شرکت Docker است که شامل مخزنی از image های آماده برای Docker می‌باشد. این مخزن حاوی ده‌ها هزار برنامه و سیستم‌عامل است که می‌توان به آن image هایی را هم اضافه کرد.

شما می‌توانید هر Docker Image را به راحتی می‌توانید با دیگران به اشتراک بگذارید. برای این کار باید Repository مناسبی با یک عنوان درخور ایجاد کنید کاری که در سایتهایی مانند bitbucket یا gitlab انجام میشود. این فرآیندهای ایجاد Reposotiry، عضویت در آن، سهم داشتن در توسعه یک Repository و... در Docker Hub انجام می‌شود. ‌اگر قصد داشته باشید از یک Docker Image فقط pull بگیرید یا لیست Imageهای عمومی موجود را جست و جو کنید نیازی به داشتن اکانت در Docker Hub  ندارید اما اگر بخواهید push انجام دهید یا نظر بدهید یا like بزنید حتماً باید در Docker Hub عضو باشید.
### Docker deployment and orchestration
هنگامی که اپلیکیشن‌ها روی چند سیستم میزبانی مقیاس می‌یابند، توانایی مدیریت هر سیستمِ میزبان و انتزاع پیچیدگی پلتفرم زیربنایی، گزینه‌ای جذاب به نظر می‌رسد. هماهنگی (Orchestration) اصطلاحی کلی است که به زمان‌بندی کانتینر، مدیریت کلاستر و احتمالاً تدارک میزبان‌های بیشتر اشاره دارد. در این محیط، منظور از زمان‌بندی (scheduling) توانایی یک مدیر برای بارگذاری یک فایل سرویس روی یک سیستم میزبان و تعیین شیوه اجرای کانتینر خاص است. با این که زمان‌بندی به عمل خاص بارگذاری تعریف سرویس اشاره دارد؛ اما در یک معنای کلی‌تر ابزارهای زمانبندی مسئول قلاب شدن به سیستم init میزبان و مدیریت سرویس‌ها در هر ظرفیتی که لازم باشد هستند.

مدیریت کلاستر به فرایند کنترل کردن گروهی از میزبان‌ها گفته می‌شود. این مدیریت می‌تواند شامل افزودن و حذف میزبان‌ها از یک کلاستر، دریافت اطلاعات در مورد وضعیت کنونی میزبان‌ها و کانتینرها، و آغاز یا توقف پردازش‌ها باشند. مدیریت کلاستر ارتباط نزدیکی با زمانبندی دارد، زیرا ابزارهای زمان‌بندی باید به همه میزبان‌ها در کلاستر دسترسی داشته باشند تا بتوانند سرویس‌ها را زمان‌بندی کنند. به این منظور در اغلب موارد از ابزار یکسانی استفاده می‌شود.
### Docker compose
Docker همچنین هماهنگی رفتارهای بین کانتینرها را آسانتر می کند و بنابراین با قرار دادن کانتینرها روی هم ، پشته های برنامه را می سازد. Docker Compose توسط Docker ایجاد شده است تا روند توسعه و تست برنامه های چند کانتینر را ساده کند. این یک ابزارcommand-line است و یک فایل توصیف کننده با قالب بندی خاص برای جمع آوری برنامه های کاربردی از چندین کانتینر و اجرای آنها به صورت هماهنگ بر روی یک میزبان را در اختیار شما قرار می دهد
### kubernetes
 رایانش ابری نیازهای جدیدی را در دنیای سخت‌افزار و نرم‌افزار ایجاد کرد و شاهد نسل جدیدی از فناوری‌ها بودیم که تعامل با رایانش ابری را ساده‌تر می‌کردند. اپلیکیشن‌های بزرگ نیز به سمت ماژولار شدن پیش رفتند تا مدیریت و تعامل با آن‌ها از جانب توسعه‌دهندگان و کاربران ساده‌تر شود.

در همین راستا گوگل به عنوان یکی از بزرگترین غول‌های فناوری که حیات خود را مدیون رایانش ابری است به این فکر افتاد تا یکی از پروژه‌های بزرگ خود را که در داخل این مجموعه از آن استفاده می‌کرد به صورت متن باز منتشر کند. این پروژه از زیرساخت‌هایی بر اساس کانتینرها بهره می‌گرفت و در داخل گوگل با نام Borg شناخته می‌شد.
جالب است بدانید Borg نقش اساسی در اجرای سرویس‌‌های مهم گوگل مانند جی‌میل و موتور جستجوی این برند داشت. به این ترتیب با متن‌باز شدن این پروژه سایر شرکت‌ها نیز قادر بودند پروژه‌های خود را همانند گوگل در ابعاد بزرگ پیش بگیرند.

به این ترتیب به زبان ساده‌تر می‌توان کوبرنتیز را وارث Borg دانست. یکی از خاصیت‌های مهم متن‌باز شدن هر پروژه‌ای توسعه سریع و گسترش آن در میان کاربران است و کوبرنتیز نیز به‌سرعت راه خود را به جوامع فناوری باز کرد و به رقیب بزرگی برای ساز و کارهای دیگر کنترل کانتینرها مانند Apache Mesos و Docker Swarm تبدیل شد.

در حال حاضر هزاران توسعه‌دهندگان با اهداف تجاری و شخصی در توسعه و بهینه‌تر کردن کوبرنتیز فعالیت دارند و شاهد ایجاد نسخه‌های تجاری کوبرنتیز نیز هستیم که شر‌کت‌های بزرگی مانند RedHat سرمایه‌گذاری‌های زیادی را برای گسترش آن انجام داده‌اند.
اگر بخواهیم به‌زبان ساده کوبرنتیز را توضیح دهیم باید بگوییم کوبرنتیز اجرا و مدیریت کانتینرهای مختلف را در سرورهای متفاوت که در یک پایگاه داده یا چندین پایگاه قرار گرفته‌اند را بر عهده می‌گیرد. در کوبرنتیز کانتینرهای مختلفی که مشترکاً برنامه کاربردی خاصی را شامل می‌شوند در حالت جداگانه و مستقل تحت عنوان پاد (Pod)‌ دسته‌بندی خواهند شد. این کار فرآیند مدیریت و شناسایی آن‌ها را ساده‌تر می‌کند.
کوبرنتیز کمک می‌کند تا کانتینرها در گروهی‌ از ماشین‌ها به صورت خودکار و اتوماتیک اجرا شوند، به این ترتیب به زبان ساده‌تر می‌توان گفت کوبرنتیز نقش سیستم‌عاملی را ایفا می‌کند که بر روی چندین سرور در حالت یکپارچه اجرا می‌شود. در نتیجه نیازی به نگرانی برای وضعیت ماشین‌های مختلف وجود ندارد و کاربران در حالی که هیچ تغییری در سرویس‌های اجرا شده مشاهده نمی‌کنند قابل تعامل با اپلیکیشن‌ها و سرویس‌های مورد نظر هستند.

## چگونگی استفاده از Docker و دستورات آن
### چگونه از یک Docker image کانتینر بسازیم؟
همان طور که در بالاتر گفته شد برای ساخت یک کانتینر نیاز به Image داریم. با داشتن این ایمیج و دستور docker run می توان کانتینر مورد نظر را ساخت.

<div dir = 'ltr'>
  
```
sudo docker run -d IMAGE_ID_OR_NAME
sudo docker run -itd IMAGE_ID_OR_NAME
```
</div>

در یکی از دستورات بالا از آپشن d و در دیگری از آپشن i و t و d استفاده کردیم. در docker run آپشن های دیگری نیز وجود دارد که در زیر به آن ها اشاره می کنیم:

  - ```-i``` : که stdin را حتی در صورت متصل نبودن باز نگه می دارد.
  - ```-t``` : یک tty از کانتینر می سازد.
  - ```-p``` : یک پورت از کانتینر را به یک پورت از هاست متصل می کند.
  - ```-v``` : یک مسیر از کانتینر را به یک مسیر از هاست مپ می کند.
  - ```-a``` : به STDIN و STDOUT یا STDERR متصل می شود.
  - ```-d``` : کانتینر را در بک گراند اجرا می کند.
  - ```--rm``` : به صورت اتوماتیک کانتینر را اگر وجود داشت حذف میکند.
  - ```--name``` : به کانتینر یک نام اختصاص می دهد.
  
در این آدرس می توانید لیست کاملی از آپشن های Docker run را مشاهده کنید.

https://docs.docker.com/engine/reference/run
  
### چگونه از حال یک کانتینر باخبر شویم ؟
در این قسمت می خواهیم نسان دهیم چگونه می توان از حال یک داکر باخبر شد.

با دستور ``` docker ps ``` می توان تمامی کانتینر های در حال اجرا را نشان داد. به عنوان مثال در زیر می توان دید.

<div dir = 'ltr'>
  
```
$ docker ps

CONTAINER ID        IMAGE                        COMMAND                CREATED              STATUS              PORTS               NAMES
4c01db0b339c        ubuntu:12.04                 bash                   17 seconds ago       Up 16 seconds       3300-3310/tcp       webapp
d7886598dbe2        crosbymichael/redis:latest   /redis-server --dir    33 minutes ago       Up 33 minutes       6379/tcp            redis,webapp/db
```

</div>

برای دیدن تمامی کانتینر ها  از دستور ``` sudo docker ps -a ``` استفاده می کنیم.
برای دیدن log یک کانتینر از دستور زیر استفاده می کنیم.

<div dir = 'ltr'>

``` sudo docker logs ID_OR_NAME_OF_A_CONTAINER ```

</div>

برای دیدن اطلاعات یک کانتینر خاص از دستور زیر استفاده می کنیم.

<div dir = 'ltr'>

``` sudo docker inspect ID_OR_NAME_OF_A_CONTAINER ```

</div>

برای استارت یا استاپ یا ریستارت کردن یک کانتینر از دستور های زیر استفاده می کنیم.

<div dir = 'ltr'>

```
sudo docker start ID_OR_NAME_OF_A_CONTAINER
sudo docker stop ID_OR_NAME_OF_A_CONTAINER
sudo docker restart ID_OR_NAME_OF_A_CONTAINER
```
</div>

### چگونه وارد کانتینر شویم؟
برای وارد شدن به کانتینر از دستور ``` docker exec ``` استفاده می کنیم.

<div dir = 'ltr'>
  
``` docker exec [OPTIONS] CONTAINER COMMAND [ARG...] ```

</div>

به عنوان مثال دستور  ``` $ docker exec -d ubuntu_bash touch /tmp/execWorks ``` فایل /tmp/execWorks را درون کانتینر ubuntu_bash در پس زمینه اجرا می کند.

### چگونه کانتینرمان را پاک کنیم؟
برای پاک کردن یک کانتینر از دستور docker rm استفاده می کنیم.

<div dir = 'ltr'>
 
``` sudo docker rm ID_OR_NAME_OF_A_CONTAINER ``` 

</div>

با این دستور تنها کانتینر هایی که در حالت stop هستند را می توان اجرا کرد. اگر کانتینر در حالت start بود از آپشن ``` -f ``` استفاده می کنیم.



## چگونه باید اپلیکیشن خودمون رو به یک container اضافه کنیم ؟


زمانی که شما container مورد نظر خودتان رو پیدا کردید قطعا میخواهید آن را customize کنید و dependency های خودتان رو به 
آن اضافه کنید . اینجا جاییست که Dockerfile مورد استفاده قرار میگیرد.

داکرفایل مشخص میکند که کانتینر شما چگونه باشد، یعنی از چه Image ای به عنوان پایه استفاده کند و چه تغییراتی روی آن اعمال کند و هنگام اجرا چه دستوراتی را اجرا کند.

در زیر یک داکرفایل نمونه به همراه توضیحات آن آمده است:

<div dir="ltr">

```dockerfile
    # Use the official Node.js runtime as a base image
    FROM node:alpine

    # Set the directory of my web application to /app
    WORKDIR /app

    # Copy over my project’s directory into the container /app folder
     Add . /app

    # Install all the dependencies for my web application
     RUN yarn install

    # Make the port 3000 accessible outside of Docker
     EXPOSE 3000

    # Execute the command yarn start
     CMD ["yarn", "start"]  

```
</div>

از روی این داکرفایل یک Image جدید ساخته شده و اجرا میشود. میتوان از روی یک Image که در اینجا بصورت داکر فایل است هر تعدادی Container ساخت.

با ساختن یک Image که تنظیمات شخصی خود را روی آن اعمال میکنیم، میتوانیم هر بار این کانتینر با تنظیمات شخصی سازی شده را بدون دوباره کاری اجرا کنیم.


## مثال دیگر (آشنایی با docker-compose)


برای آشنایی بیشتر یک image برای راه اندازی یک پروژه جنگو میسازیم:
برای ساخت یک image ابتدا لازم است تا یک Dockerfile بسازیم و درون آن با نوشتن دستوراتی چگونگی ساختن image را به docker نشان دهیم. در واقع image دلخواه خود را برای docker توصیف میکنیم.

<div dir="ltr">

    FROM python:3.6
    ENV PYTHONUNBUFFERED 1
    RUN mkdir /my_app_dir
    WORKDIR /my_app_dir
    ADD requirements.txt /my_app_dir/
    RUN pip install — upgrade pip && pip install -r requirements.txt
    ADD . /my_app_dir/
    
</div>

در خط دوم با کلید واژه ENV میتوایم Environment Variable ها را برای app جنگو خود set کنیم. در واقع با این دستور درون کانتینر خود مقدار Environment Variable ای با نام PYTHONUNBUFFERED را برابر ۱ قرار میدهیم.

از آنجایی که به یک دیتابیس هم نیاز داریم میتونیم از یک image آماده mysql استفاده کنیم.
وقتی تعداد کانتینر ها زیاد میشود باید از ابزاری به اسم docker-compose استفاده کنیم.

این ابزار به راحتی قابل نصب است:
<div dir="ltr">

```$bash
    sudo apt install docker-compose
```
</div>
حال یک فایل به نام docker-compose.yml میسازیم با محتوای زیر:

<div dir="ltr">

```docker-compose
version: '3'

services:
  db:
     # Use the official mysql version 5.7 as a base image
    image: mysql:5.7

    # Mapping port 3306 inside container to port 3306 in our os network
    ports:
      - '3306:3306'

    # Setting environment variables
    environment:
       MYSQL_DATABASE: 'my-app-db'
       MYSQL_USER: 'root'
       MYSQL_PASSWORD: 'password'
       MYSQL_ROOT_PASSWORD: 'password'

  web:
    # Choosing the directory containing our Dockerfile
    build: .

    # Running this command every time we run our container
    command: python manage.py runserver 0.0.0.0:8000

    # Mounting current directory into container's /my_app_dir directory
    volumes:
      - .:/my_app_dir
    ports:
      - "8000:8000"

    # web Container will run after db
    depends_on:
      - db
```
</div>

درواقع هر کدام از سرویس هایی که درون docker-compose.yml تعریف میکنیم نشان دهنده یک کانتینر است که به وسیله این فایل میتوانیم آنها را به یکدیگر متصل کرده و فایل ها و شبکه های آن ها را با هم به اشتراک بگذاریم.

حال کافیست بقیه تنظیمات پروژه را انجام دهیم.
 فایل requirements.txt در دایرکتوری root پروژه جنگو :
 <div dir="ltr">

 ```
Django==1.11.5
mysqlclient==1.3.12
django-mysql==2.2.0
... (whatever else your app requires) ...
```
</div>

فایل my_app_dir/settings.py :
<div dir="ltr">

```
...
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': 'my-app-db',
        'USER': 'root',
        'PASSWORD': 'password',
        'HOST': 'db',
        'PORT': 3306,
    }
}
...
```
</div>

و در آخر:

<div dir="ltr">

```
    # building images from Dockerfiles
    docker-compose build

    # running your containers
    docker-compose up -d
```
</div>

و برای migrate کردن دیتابیس درحالی که کانتینر ها در حال کار کردن هستند به صورت زیر میتونید دستور migrate را درون کانتینر در حال اجرا، اجرا کنید.
<div dir="ltr">

```dockerfile
    docker-compose run web python manage.py migrate
```
</div>



## مزایای Docker
۱. تکرارپذیری:
یک برنامه‌ی جاوا در هر دستگاهی است که قادر به اجرای یک ماشین مجازی جاوا باشد، دقیقا به صورت مشابه قابل اجراست. اجرای Docker نیز همانند جاوا، در هر سیستمی که می‌تواند Docker را اجرا کند، تضمین شده است. مشخصات دقیق container در یک فایل Dockerfile ذخیره می‌شود. با توزیع این فایل در بین اعضای تیم، یک سازمان می‌تواند تضمین کند که تمام فایل‌های image ساخته شده با همان Dockerfile یکسان کار می‌کنند. علاوه بر این، داشتن محیطی ثابت و مستند، باعث می‌شود که track کردن اپلیکیشن شما و شناسایی مشکلات آسان تر شود.

۲. جداسازی:
متعلقات و تنظیمات یک container، روی برنامه‌های دیگر رایانه‌ی شما تاثیر نمی‌گذارند. حتی اگر یک container دیگر نیز همزمان درحال اجرا باشد. با استفاده از container‌های جداگانه برای هر جزء یک برنامه (به عنوان مثال یک وب سرور، رابط کاربری و یا پایگاه داده برای میزبانی یک وب‌سایت)، می‌توانید از مغایرت متعلقات جلوگیری کنید. شما همچنین می‌توانید پروژه های متعددی را در یک سرور داشته باشید بدون آنکه نگران مغایرت‌ها باشید.

۳. امنیت:
جداسازی اجزای مختلف یک برنامه بزرگ در container‌های مختلف می‌تواند مزایای امنیتی داشته باشد. برای مثال اگر یک container به خطر بیافتد دیگران امن باقی می مانند.

۴. Docker Hub:
برای موارد رایج و ساده استفاده می‌شود، مانند یک استک LAMP. توانایی ذخیره image و انتقال آن‌ها به Docker Hub به این معنی است که همیشه تعداد زیادی image که به خوبی می‌توان آن‌ها را مدیریت و کنترل کرد، در دسترس هستند. این‌که بتوانیم به راحتی یک image را دریافت و تغییر داده و آن را build کنیم، بسیار به سرعت و سهولت روند راه‌اندازی کمک می‌کند.

۵. مدیریت محیط:
Docker مدیریت و نگهداری ورژن‌های مختلف را آسان می‌کند؛ مثلا ورژن‌های مختلف وب‌سایتی که از nginx استفاده می‌کند. شما می‌توانید برای هریک از اهداف آزمایش، توسعه و تولید، یک container جداگانه در یک Linode داشته باشید و به راحتی هریک را توسعه دهید.

۶. یکپارچه سازی مداوم:
Docker به عنوان جزئی از سری پیوسته integration با ابزارهایی مانند Travis، Jenkins و Wercker کار می‌کند. هر بار که کد source شما به روز می شود، این ابزار می تواند نسخه جدید را به عنوان یک Docker Image ذخیره کند، آن را با یک شماره نسخه برچسب‌گذاری کرده و به Docker Hub منتقل کند، سپس آن را deploy کند.

</div>
