<div dir = 'rtl' style='text-align:justify'>
# docker-compose (بخش دوم)

در این نوشته قرار است تا **وبلاگ ساده‌ای** را که بکِ آن با جنگو رست و فرانتش با ری‌اکت زده‌شده، به وسیله‌ی docker-compose اجرا کنیم.

compose ابزاری‌ست که به وسیله‌ی آن می‌توانیم برنامه‌های دارای چند container را اجرا کنیم. به هر container به چشم یک سرویس جداگانه نگاه می‌کنیم که تنظیماتِ docker مخصوص به خود را دارد.

مثلا در همین وبلاگ ساده، سه service مختلف داریم:
- فرانت‌اند
- بک‌اند
- nginx (که وظیفه‌ی routing و هدایت درخواست‌ها بین فرانت و بک را دارد)

serviceهای دیگری از جمله database هم وجود دارد که البته در ساختن این وبلاگ به دیتابیس به صورت سرویسی جدا، احتیاجی نداریم.

هدف compose این است که همه‌ی این سرویس‌های مختلف را هماهنگ با هم و با توجه به وابستگی احتمالی میان آن‌ها اجرا کند. مثالی از وابستگی احتمالی، اجرا شدنِ service بک و سپس اجرا شدن سرویس database است. واضح است که بدون بودن منطق برنامه، دیتابیس نمی‌تواند اجرا شود!

## نصب compose

این ابزار به راحتی و از طریق دستور زیر، قابل نصب است:
<div dir="ltr">

```$bash
sudo apt install docker-compose
```
</div>

## استفاده از compose

استفاده از compose سه مرحله دارد:
- اول از همه باید برای هر سرویس به صورت جداگانه تنظیمات docekr مخصوص خودش را بنویسیم. این کار در قسمت قبلیِ همین مستند توضیح داده شد.

    با نوشتن این تنظیمات، برای هر سرویس محیط ایزوله‌ای ایجاد می‌کنیم که می‌توان در هر جای پروژه از آن استفاده کرد. هم‌چنین با این کار امکان استفاده‌ی مجدد از container وحود دارد.

- حال که سرویس‌های مختلفی در اختیار داریم، باید یک سرویس **جامع‌تر** داشته باشیم که تمام سرویس‌های دیگر را مدیریت می‌کند؛ مثلا اشتراک فایل‌ها و شبکه از طریف این سرویس جامع‌تر انجام می‌شود. این‌جاست که سر و کله‌ی docker-compose پیدا می‌شود! تنظیمات مربوط به compose در فایلی با نام `docker-compose.yml` نوشته می‌شود که جلوتر به آن می‌پردازیم.

- اکنون وقتِ اجراست! به سادگی با وارد کردن دستور `docker-compose build`،  compose کار خود را شروع و تمام سرویس‌های پروژه‌ی شما را اجرا می‌کند.

* توجه کنید که پسوند `.yml` با پسوند `.yaml` تفاوتی ندارد و هر دو می‌توانند به عنوان پسوند برای docker-compose file استفاده شوند.

## امکانات docker-compose
- docker-compose امکان ایجاد چند محیط ایزوله شده از یک‌دیگر را فراهم می‌کند. این محیط‌ها می‌توانند هم‌زمان با هم، بر روی یک کامپیوتر اجرا شوند. 
- داده‌ها در containerهای ایجاد شده از بین نمی‌رود و با اجرای مجدد دستورِ `docker-compose up`، اطلاعات قبلیِ container بر روی container جدید کپی می‌شود.
- در هنگام ساخته یا همان buildشدن container کلی، containerهایی که از قبل ساخته شده بودند و تغییری نکرده‌اند، مجددا ساخته نمی‌شوند و این باعث افزایش سرعتِ buildشدن در دفعات بعدی می‌شود.	


## بررسی docker-compose بر روی پروژه‌ی وبلاگ

همان‌طور که قبل‌تر هم گفتیم، در این مثال ما سه سرویس مختلف داریم:
- بک‌اند
- فرانت‌اند
- nginx

توجه کنید که در این پروژه، سرویس جداگانه‌ای برای دیتابیس نداریم و دیتابیس در  داخل سرویس بک‌اند اجرا می‌شود.

دستورات نوشته شده در docker-compose.yml این پروژه به صورت زیر هستند:

<div dir='ltr'>

```docker-compose

version: '3'

services:
  # سرویس اول
  backend:
    build:
      # هنگامی که دستور بیلد داده شد، از همین‌جایی که هستی به آدرس زیر برو
      # و دستورات داکرفایلی را که آن جا است، اجرا کن
      context: ./blog_backend
      # هنگامی که دستور بیلد داده شد، آرگومان‌های زیر را به محیط کانتینرِ بک پاس بده
      args:
        DJANGO_ALLOWED_HOSTS: localhost, api
        DJANGO_SECRET_KEY: 'A_RANDOM_SECRET_KEY'
        DJANGO_CORS_ORIGIN_WHITELIST: http://localhost
    # پس از بیلد شدنِ کانتینرِ بک‌اند، دستور زیر را اجرا کن 
    command: gunicorn blog_backend.wsgi --bind 0.0.0.0:8000
    # پورت‌های درون کانتینر را با پورت‌های شبکه‌ی سیستم‌عامل نظیر کن
    ports:
      - "8000:8000"

  # سرویس دوم
  frontend:
    build:
      context: ./blog_frontend
      args:
        API_URL: http://localhost
    # یک فضای مشترک با سرویسِ ان‌جین‌ایکس ایجاد کن و از طریق این فضا با ان‌جین‌ایکس در ارتباط باش
    volumes:
      - build_folder:/frontend/build

  # سرویس سوم
  nginx:
    image: nginx:latest
    ports:
      - 80:8080
    volumes:
      - ./webserver/nginx-proxy.conf:/etc/nginx/conf.d/default.conf:ro
      - build_folder:/var/www/frontend
    # صبر کن تا اول دو سرویس دیگر اجرا شوند، سپس این سرویس را اجرا کن
    depends_on:
      - backend
      - frontend
volumes:
  build_folder:
```
</div>

همان‌طور که می‌بینید، چهار آرگومان در فایل `docker-compose.yml` وجود دارند که می‌توانیم با توجه نیازمان، به آن‌ها مقدار بدهیم؛
مثلاً در این جا، چون هر سه سرویسِ بک، فرانت و nginx بر روی `localhost` قرار دارند، بنابراین مقدار این آرگومان‌ها را برابر `localhost` قرار داده‌ایم.
البته مقدار آرگومان `DJANGO_SECRET_KEY` می‌تواند هر چیز دلخواهی باشد.

در نهایت با اجرای دستور `docker-compose build`، سرویس جامع‌تر از روی دستورات نوشته شده در `docker-compose.ymp` اقدام به ساختن containerها می‌کند


و در مرحله‌ی بعد، با اجرای دستور `docker-compose up`، همه‌ی containerها با هم اجرا می‌شوند.

در این مثال وبلاگ، پس از اجرای دستور `docker-compose up`، سرویس فرانت بر روی `localhost` قرار می‌گیرد و برای دسترسی به apiهای ارائه‌شده توسط سرویس بک نیز می‌توانیم به آدرس `localhost/api/posts` درخواست بزنیم.
